---
title: 一些js基础算法
date: 2017-07-21 15:00:44
layout: post
comments: true
categories: js
tags: [算法]
keywords: 算法
---
## 前言
长时间没有接触算法,脑子生锈,写下一些常见的排序、查找算法记在博客上给自己看,代码没有写注释。

<!-- more -->
## 排序

```js
    var array = [32, 80, 1, 13, 7, 36, 49, 2, 33, 20, 55]
```

### 1. 冒泡排序

```js
    function bubbleSort(arr) {
    	var l = arr.length;
    	for (var i = 0; i < l; i++) {
    		for (var j = 0; j < l - i - 1; j++) {
    			if (arr[j] > arr[j + 1]) {
    				var temp = arr[j];
    				arr[j] = arr[j + 1];
    				arr[j + 1] = temp;
    			}
    		}
    	}
    	return arr
    }
    function bubbleSort2(arr) {
    	var i = arr.length - 1;
    	while (i > 0) {
    		var position = 0;
    		for (var j = 0; j < i; j++) {
    			if (arr[j] > arr[j + 1]) {
    				position = j;
    				var temp = arr[j];
    				arr[j] = arr[j + 1];
    				arr[j + 1] = temp;
    			}
    		}
    		i = position;
    	}
    	return arr
    }
    console.log(bubbleSort(array))
    console.log(bubbleSort2(array))
```

### 2. 选择排序

```js
    function selectionSort(arr) {
    	var l = arr.length, minIndex, temp;
    	for (var i = 0; i < l - 1; i++) {
    		minIndex = i;
    		for (var j = i + 1; j < l; j++) {
    			if (arr[j] < arr[minIndex]) {
    				minIndex = j;
    			}
    		}
    		temp = arr[i];
    		arr[i] = arr[minIndex];
    		arr[minIndex] = temp;
    	}
    	return arr
    }
    console.log(selectionSort(array))
```

### 3. 插入排序

```js
   function insertionSort(arr) {
   	var l = arr.length, preIndex, current;
   	for (var i = 0; i < l; i++) {
   		preIndex = i - 1;
   		current = arr[i];
   		while (preIndex >= 0 && arr[preIndex] > current) {
   			arr[preIndex + 1] = arr[preIndex];
   			preIndex--;
   		}
   		arr[preIndex + 1] = current;
   	}
   	return arr
   }
   console.log(insertionSort(array))
```

### 4. 归并排序

```js
    function mergeSort(arr){
    	function _merge(left,right){
    		var res = [],l_i = 0, r_i = 0
    		while(l_i<left.length && r_i<right.length){
    			if(left[l_i]<right[r_i]){
    				res.push(left[l_i++])
    			} else {
    				res.push(right[r_i++])
    			}
    		}
    		return res.concat(left.slice(l_i),right.slice(r_i))
    	}
    	function _ms(a){
    		if(a.length < 2) return a
    		var pivotIndex = Math.floor(a.length/2)
    		var left = a.slice(0,pivotIndex)
    		var right = a.slice(pivotIndex)
    		return _merge(_ms(left),_ms(right))
    	}
    	return _ms(arr)
    }

    console.log(mergeSort(array))
```

### 5. 快速排序

```js
    // Nicholas C. Zakas 实现 in-place 不借助额外数组,节省空间
    //https://www.nczonline.net/blog/2012/11/27/computer-science-in-javascript-quicksort/
    function swap(items, firstIndex, secondIndex){
        var temp = items[firstIndex];
        items[firstIndex] = items[secondIndex];
        items[secondIndex] = temp;
    }
    function partition(items, left, right) {

        var pivot   = items[Math.floor((right + left) / 2)],
            i       = left,
            j       = right;


        while (i <= j) {

            while (items[i] < pivot) {
                i++;
            }

            while (items[j] > pivot) {
                j--;
            }

            if (i <= j) {
                swap(items, i, j);
                i++;
                j--;
            }
        }

        return i;
    }
    function quickSort(items, left, right) {

        var index;

        if (items.length > 1) {

            left = typeof left != "number" ? 0 : left;
            right = typeof right != "number" ? items.length - 1 : right;

            index = partition(items, left, right);
    		console.log(index,items[index],items)

            if (left < index - 1) {
                quickSort(items, left, index - 1);
            }

            if (index < right) {
                quickSort(items, index, right);
            }

        }

        return items;
    }
```

### 5. 堆排序

```js
    function heapSort(arr) {
    	var l
    	// 创建大顶堆
    	function _buildMaxHeap(arr) {
    		l = arr.length
    		for (var i = Math.floor(l / 2); i >= 0; i--) {
    			_heapify(arr, i)
    		}
    	}

    	// 调整堆
    	function _heapify(arr, i) {
    		var left = 2 * i + 1,
    			right = 2 * i + 2,
    			max = i
    		if (left < l && arr[left] > arr[max]) {
    			max = left
    		}
    		if (right < l && arr[right] > arr[max]) {
    			max = right
    		}

    		if (max != i) {
    			var temp = arr[i]
    			arr[i] = arr[max]
    			arr[max] = temp

    			_heapify(arr, max)
    		}
    	}

    	_buildMaxHeap(arr)

    	for (var i = arr.length - 1; i > 0; i--) {
    		var temp = arr[0]
    		arr[0] = arr[i]
    		arr[i] = temp
    		l--
    		_heapify(arr, 0)
    	}
    	return arr
    }

    console.log(heapSort(array))
```

## 查找

### 1. 二分法

```js
    function binarySearch(arr,target){
    	var startIndex = 0,
    		endIndex = arr.length - 1,
    		pivotIndex = Math.floor((endIndex - startIndex)/2)
    	while(arr[pivotIndex] !=target && startIndex < endIndex){
    		if(target < arr[pivotIndex]){
    			endIndex = pivotIndex - 1
    		} else if(target > arr[pivotIndex]){
    			startIndex = pivotIndex + 1
    		}
    		pivotIndex = Math.floor((endIndex - startIndex)/2)
    	}
    	return arr[pivotIndex] != target ? -1 : pivotIndex
    }
    console.log(binarySearch([32, 80, 1, 13, 7, 36, 49],1))
```

### 2. 最大子串

```js
    function getMaxSub(s1, s2) {
    	var max = 0, retchars = [];
    	for(var index = 0; index < s1.length; index++){
    		var count = 0, chars = []; // 每次遍历都置空
    		for(var i = index, j = 0; j < s2.length; j++){
    			var s1char = s1[i];
    			var s2char = s2[j];
    			if(s1char === s2char){
    				count++;
    				i++;
    				chars.push(s1char);
    			} else if(count) { // 如果不相同且有相同过则count和chars置空，i复位，j回退一位
    				j--;
    				count = 0;
    				chars = [];
    				i = index;
    			}
    			if(count > max) {
    				max = count;
    				retchars = chars.slice();
    			}
    		}
    	}
    	return retchars.join('');
    }

    getMaxSub('abcde','rodcdpp')
```

### 3. 二维数组查找

```js
    var findTarget = function (target, arr) {
    	console.log(arr)
    	var l = arr.length,
    		i = l - 1,
    		j = 0
    	while (i >= 0 && arr[i][j]) {
    		if (arr[i][j] < target) {
    			j++
    		}
    		else if(arr[i][j] > target) {
    			i--
    		} else {
    			console.log(i,j)
    			return true
    		}
    		return false
    	}
    }

    var dda = [[1, 2, 4, 6], [2, 4, 7, 8], [8, 9, 10, 11], [9, 12, 13, 15]]
    console.log(findTarget(19, dda))
```

## 杂七杂八

### 字符串转数字

```js
    function atoi(n) {
    	return n.split("").reduce((prev, curr, index) => {
    		console.log(prev,curr)
    		return prev * 10 + (curr - '0')
    	}, 0)
    }
```

### 洗牌

```js
        function shuffleFn(a) {
            let b = []
            for(var i = a.length;i>0;){
                var index = Math.floor(Math.random() * i);
                b.push(a[index])
                a[index] = a[--i]
            }
            return b
        }
        shuffleFn([12,53,21,6,33,332,422,987,343645,2])
```

### 斐波那契尾递归和缓存版

```js
            // 尾递归
            function fibonacci(n, ac1 = 1, ac2 = 1) {
                if (n <= 1) {
                    return ac1;
                }
                return fibonacci(n - 1, ac2, ac1 + ac2);
            }
            // cache
            var fib_cache = function () {
                var cache = [1, 1];
                return function (n) {
                    if (n >= cache.length) {
                        for (var i = cache.length; i < n; i++) {
                            cache[i] = cache[i - 1] + cache[i - 2];
                        }
                    }
                    return cache[n - 1];
                }
            }()
```

### 深拷贝

```js
            function is(obj, type) {
                return Object.prototype.toString.call(obj).slice(8, -1) === type;
            }
            function copy(obj, isDeep) {
                var ret = obj.slice ? [] : {}, p;
                if (!isDeep && is(obj, 'Array')) return obj.slice();
                for (p in obj) {
                    var prop = obj[p];
                    if (!obj.hasOwnProperty(p)) continue;
                    if (is(prop, 'Object') || is(prop, 'Array')) {
                        ret[p] = copy(prop, isDeep);
                    } else {
                        ret[p] = prop;
                    }
                }
                return ret;
            }
```

### 数组去重

```js
            Array.prototype.unique = Array.prototype.unique || function () {
                        var hash = {}, res = [];
                        for (var i = 0, l = this.length; i < l; i++) {
                            if (!hash.hasOwnProperty(this[i])) {
                                hash[this[i]] = true;
                                res.push(this[i]);
                            }
                        }
                        return res;
                    }
```

### 数组取交集

```js
             Array.prototype.unique = Array.prototype.unique || function () {
                        var hash = {}, res = [];
                        for (var i = 0, l = this.length; i < l; i++) {
                            if (!hash.hasOwnProperty(this[i])) {
                                hash[this[i]] = true;
                                res.push(this[i]);
                            }
                        }
                        return res;
                    }
```
