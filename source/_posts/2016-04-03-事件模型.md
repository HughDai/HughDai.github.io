---
title: 事件模型
date: 2016-04-03 17:27:16
tags:
---
## 事件触发过程
在前端开发中，经常会遇到事件监听，很多人对事件捕获及事件冒泡不置可否，以下是我对事件模型的一些看法，简单来说就是从外向内捕捉，然后到目标阶段后依次向上冒泡，详情请自行[W3C](https://www.w3.org/TR/DOM-Level-3-Events/#event-flow)。
图片引用自[W3C](https://www.w3.org/TR/DOM-Level-3-Events/#event-flow)
![](/img/eventflow.png)
    1、捕获阶段：在事件对象到达事件目标之前，事件对象必须从window经过目标的祖先节点传播到事件目标。 这个阶段被我们称之为捕获阶段。在这个阶段注册的事件监听器在事件到达其目标前必须先处理事件。
    2、目标阶段：事件对象到达其事件目标。 这个阶段被我们称为目标阶段。一旦事件对象到达事件目标，该阶段的事件监听器就要对它进行处理。如果一个事件对象类型被标志为不能冒泡。那么对应的事件对象在到达此阶段时就会终止传播。
    3、冒泡阶段：事件对象以一个与捕获阶段相反的方向从事件目标传播经过其祖先节点传播到window。这个阶段被称之为冒泡阶段。在此阶段注册的事件监听器会对相应的冒泡事件进行处理。
## 跨浏览器EventUtil
以下是js大神[Nicholas Zakas](https://github.com/nzakas/)写的[Professional JavaScript for Web Developers](https://www.amazon.cn/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E6%B3%BD%E5%8D%A1%E6%96%AF/dp/B007OQQVMY)中的Cross Browser Event Utility
查看[Hugh Dai Gist](https://gist.github.com/HughDai/a365e2515643e861ceff6b6181400449)
```javascript
    var EventUtil = {
                addHandler: function( element, type, handler ) {
                    if ( element.addEventListener ) {
                        element.addEventListener ( type, handler, false );
                    } else if ( element.attachEvent ) {
                        element.attachEvent ( "on" + type, handler );
                    } else {
                        element["on" + type] = handler;
                    }
                },
                getEvent: function ( event ) {
                    return event ? event : window.event;
                },
                getTarget: function ( event ) {
                    return event.target || event.srcElement;
                },
                preventDefault: function ( event ) {
                    if ( event.preventDefault ) {
                        event.preventDefault();
                    } else {
                        event.returnValue = false;
                    }
                },
                removeHandler: function( element, type, handler ) {
                    if ( element.removeEventListener ) {
                        element.removeEventListener ( type, handler, false );
                    } else if ( element.detachEvent ) {
                        element.detachEvent ( "on" + type, handler );
                    } else {
                        element["on" + type] = null;
                    }
                },
                stopPropagation: function ( event ) {
                    if ( event.stopPropagation ) {
                        event.stopPropagation();
                    } else {
                        event.cancelBubble = true;
                    }
                }
            };
```

## Demo
这里修改一下大神[Wilson Page](https://github.com/wilsonpage)的一个demo，更形象的描述事件流模型。

<p data-height="600" data-theme-id="0" data-slug-hash="BzNjax" data-default-tab="js,result" data-user="HughDai" data-embed-version="2" class="codepen">See the Pen <a href="http://codepen.io/HughDai/pen/BzNjax/">BzNjax</a> by Hugh Dai (<a href="http://codepen.io/HughDai">@HughDai</a>) on <a href="http://codepen.io">CodePen</a>.</p>
<script async src="//assets.codepen.io/assets/embed/ei.js"></script>