---
title: Math.floor和位操作
date: 2018-07-11 10:42:39
layout: post
comments: true
categories: js
tags: [js]
keywords: js,位运算
---
## 前言
在学习js运算符的过程中，大家应该对[按位操作符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators)不会感到陌生，但是相信大部分人在编码中用到位操作的机会寥寥，甚至于有些新手同学压根不知道js还有位运算或者某些逻辑运算符。比如一个简单的逻辑运算符 !! ，前阵子组里一个同学来问这是什么意思，解释了大半天。在看各种源码的时候，经常会碰到 !!、~~ 、>> 之类的运算符，刚出道的时候我也是不求甚解，后来看多了自然明了了。本文主要说说自己对Math.floor和位操作的关系和对比，其他的不多讲。
![](/images/bitwise.png)
<!-- more -->

## 概念
1、先说说一个逻辑运算符 !!
要想了解 !! 首先要了解逻辑非运算符 ! ，先看看ECMA-262的定义
>产生式 UnaryExpression : ! UnaryExpression 按照下面的过程执行 :

>1、令 expr 为解释执行 UnaryExpression 的结果 .
>2、令 oldValue 为 ToBoolean(GetValue(expr)).
>3、如果 oldValue 为 true ，返回 false.
>4、返回 true.

说白了就是ToBoolean返回的oldValue为true，就为false，否则为true。理解了逻辑非 ! 就不难理解了，!! 的意思就是直接返回 ToBoolean(GetValue(expr)) ，目的是将操作数转化为布尔类型，相当于 Boolean(value)。看看几个例子：
``` js
!! 1 // true
!! 0 // false
!! null // false
!! undefined // false
!! NaN //false
!! '' // false
!! 'abc' // true
!! 100 // true
```
2、~~
同样要想理解 ~~ 首先要知道按位非操作符 ~ 的概念，正如上面MDN截图所示，按位非的意思即对每一个比特位进行非操作求反码再求补码。还是先看ECMA-262的定义
>产生式 UnaryExpression : ~ UnaryExpression 按照下面的过程执行 :

>1、令 expr 为解释执行 UnaryExpression 的结果 .
>2、令 oldValue 为 ToInt32(GetValue(expr)).
>3、返回 oldValue 按位取反的结果。结果为 32 位有符号整数。

看一个MDN上的例子：
```js
~9 = -10
// why 是不是感到很奇怪，我又温习了一遍反码补码的知识
// 10进制的数字9转换为二进制原码 0 0000000000000000000000000001001
// 然后对每一位进行按位非 1 1111111111111111111111111110110
// 然后再求反，符号位为1表示为负数，符号位不变，1 0000000000000000000000000001001
// 末尾+1 得到补码 1 0000000000000000000000000001010
// 得到 -10
```
所以对任一数值 x 进行按位非操作的结果为 -(x + 1)。
明白了按位非 ~ 的意思，下面看 ~~，顾名思义就是在 ~ 的基础上再做一次按位非，等于省略掉定义中的第三步返回 ToInt32(GetValue(expr))，目的是将操作数转化为32位有符号的整数类型，得到结果-(-(x+1) + 1)，看看几个例子：
```js
~~ 0 // 0
~~ 1 // 1
~~ null // 0
~~ undefined // 0
~~ NaN // 0
~~ '' // 0
~~ 'abc' // 1
~~ 1.4 // 1
~~ -1.4 // -1
~~ 1.5 // 1
~~ -1.5 // -1
```
3、<< (左移) 和 >>(有符号右移)
<< 操作符会将左边的操作数向左移动指定的位数，向左被移出的位将被丢弃，右侧会以0补充。
看一个MDN上的例子：
```js
9 << 2 = 36
// 10进制的数字9转换为二进制原码 00000000000000000000000000001001
// 向左移动两位，丢弃左侧两位，右侧补0得到二进制 00000000000000000000000000100100即10进制 36
```
所以得到公式 x << y = x * Math.pow(2, y)。看几个例子：
```js
null << 0 // 0
undefined << 0 // 0
NaN << 0 // 0
12345 << 0 // 12345
-12345 << 0 // -12345
30.12 << 0 // 30
30.54 << 0 // 30
1 << 1 // 2
1 << 2 // 4
-1 << 1 // -2
'12345' << 0 // 12345
'' << 0 // 0
'abc' << 0 // 0
```
\>> 操作符会将左边的操作数向右移动指定的位数，向右被移出的位被丢弃，拷贝最左侧的符号位以填充左侧。由于新的最左侧的位总是和以前相同，符号位没有被改变。所以被称作“符号传播”。
看一个MDN上的例子：
```js
9 >> 2 = 2
// 10进制的数字9转换为二进制原码 00000000000000000000000000001001
// 向右移两位，左侧补两位符号位 00 得到 00000000000000000000000000000010 即10进制 2

-9 >> 2 = -3
// 有符号10进制 -9 补码 11111111111111111111111111110111
// 右移两位 11111111111111111111111111111101 即有符号10进制 -3
```
看看例子：
```js
null >> 0 // 0
undefined >> 0 // 0
NaN >> 0 // 0
12345 >> 0 // 12345
-12345 >> 0 // -12345
30.12 >> 0 // 30
30.54 >> 0 // 30
1 >> 1 // 0
-1 << 1 // -1
'12345' >> 0 // 12345
'' >> 0 // 0
'abc' >> 0 // 0
```
4、Math.floor
Math.floor() 返回小于或等于一个给定数字的最大整数。看一下MDN的例子：
```js
Math.floor( 45.95) // 45
Math.floor( 45.05) // 45
Math.floor( 4 ) // 4
Math.floor(-45.05) // -46
Math.floor(-45.95) // -46
Math.floor(NaN) // 0
Math.floor(null) // 0
Math.floor(undefined) // NaN
```
## Math.floor和 ~~ 、<< 、>> 的关系
上面列举了那么多例子，可能会发现在x为正数的时候 Math.floor(x) 和 ~~ x 、x << 0 、x >> 0 都能够达到向下取整的效果。**因为js中所有数字都是以64位浮点数形式储存，当进行位运算的时候都有ToInt32这一步骤舍弃了小数，达到向下取整的效果。**
看过好多源码中都有 ~~ x 和 >> 0 等类似向下取整的写法，相对于 Math.floor 写起来比较方便，听说效率也高。为了测试我在jsperf.com上写了个test case [mathfloorvsbitwise](https://jsperf.com/mathfloorvsbitwise)，发现位运算都比Math.floor快些。
![](/images/mathfloorvsbitwise.png)
